"""analyzer to get Radial Distribution Function (RDF) across different frames"""
from __future__ import annotations
from typing import Iterable, Optional, Sequence, Tuple, List, Dict, Union
import numpy as np
import pandas as pd

# FREUD backend (pip install freud-analysis)
import freud

# OVITO backend (pip install ovito)
from ovito.io import import_file
from ovito.modifiers import CoordinationAnalysisModifier
from reaxkit.io.xmolout_handler import XmoloutHandler


# ==========================================================
# =============== Single-frame RDF backends ================
# ==========================================================

def rdf_freud_frame(
    handler: XmoloutHandler,
    frame_index: int,
    *,
    types_a: Optional[Iterable[str]] = None,
    types_b: Optional[Iterable[str]] = None,
    r_max: Optional[float] = None,
    bins: int = 200,
    drop_first_bin: bool = True,
) -> Tuple[np.ndarray, np.ndarray]:
    """Compute RDF for ONE frame using freud.
    Returns (r, g). No smoothing, no cross-frame averaging.
    """
    df = handler.dataframe()
    fr = handler.frame(int(frame_index))

    coords = fr["coords"]
    atom_types = np.asarray(fr["atom_types"], dtype=str)

    # Box from sim DF (supports non-orthogonal if available)
    row = df.iloc[int(frame_index)]
    a, b, c = float(row["a"]), float(row["b"]), float(row["c"])
    alpha = float(row["alpha"]) if "alpha" in df.columns else 90.0
    beta  = float(row["beta"])  if "beta"  in df.columns else 90.0
    gamma = float(row["gamma"]) if "gamma" in df.columns else 90.0

    box = freud.box.Box.from_box_lengths_and_angles(
        a, b, c, np.radians(alpha), np.radians(beta), np.radians(gamma)
    )

    # A/B masks
    A_mask = np.ones(len(atom_types), dtype=bool) if types_a is None else np.isin(atom_types, list(types_a))
    B_mask = np.ones(len(atom_types), dtype=bool) if types_b is None else np.isin(atom_types, list(types_b))
    A = coords[A_mask]
    B = coords[B_mask]

    if r_max is None:
        r_max = 0.5 * float(min(a, b, c))

    rdf = freud.density.RDF(bins=int(bins), r_max=float(r_max))
    rdf.compute((box, B), query_points=A)

    r = rdf.bin_centers.copy()
    g = rdf.rdf.copy()
    if drop_first_bin and len(r) > 1:
        r, g = r[1:], g[1:]
    return r, g


def _write_xyz_temp(coords: np.ndarray, types: Sequence[str]) -> str:
    import tempfile, os
    def _norm(sym: str) -> str:
        s = str(sym).strip()
        return s[:1].upper() + s[1:].lower()
    n = coords.shape[0]
    fd, path = tempfile.mkstemp(suffix=".xyz", prefix="reaxkit_rdf_")
    os.close(fd)
    with open(path, "w") as f:
        f.write(f"{n}\n")
        f.write("generated by reaxkit RDF (single-frame)\n")
        for t, (x, y, z) in zip(types, coords):
            f.write(f"{_norm(t)} {x:.9f} {y:.9f} {z:.9f}\n")
    return path


def rdf_ovito_total_frame(
    handler: XmoloutHandler,
    frame_index: int,
    *,
    r_max: float = 4.0,
    bins: int = 200,
) -> Tuple[np.ndarray, np.ndarray]:
    """Total RDF for ONE frame via OVITO."""
    fr = handler.frame(int(frame_index))
    coords = fr["coords"]
    types = fr["atom_types"]

    import os
    xyz = _write_xyz_temp(coords, types)
    try:
        pipe = import_file(xyz)
        pipe.modifiers.append(CoordinationAnalysisModifier(cutoff=float(r_max), number_of_bins=int(bins), partial=False))
        data = pipe.compute()
        table = data.tables["coordination-rdf"]
        arr = table.xy()
        r = np.asarray(arr[:, 0])
        g = np.asarray(arr[:, 1])
        return r, g
    finally:
        try: os.remove(xyz)
        except OSError: pass


def rdf_ovito_partial_frame(
    handler: XmoloutHandler,
    frame_index: int,
    *,
    r_max: float = 4.0,
    bins: int = 200,
    type_a: str,
    type_b: str,
) -> Tuple[np.ndarray, np.ndarray]:
    """Partial RDF (type_a–type_b where a and b can be Al and N as an example) for ONE frame via OVITO."""
    fr = handler.frame(int(frame_index))
    coords = fr["coords"]
    types = fr["atom_types"]

    import os
    xyz = _write_xyz_temp(coords, types)
    try:
        pipe = import_file(xyz)
        pipe.modifiers.append(CoordinationAnalysisModifier(cutoff=float(r_max), number_of_bins=int(bins), partial=True))
        data = pipe.compute()
        base = "coordination-rdf"
        if base not in data.tables:
            raise KeyError(f"'{base}' table not found. Available: {list(data.tables.keys())}")
        table = data.tables[base]

        # locate the pair component
        try:
            names = list(table.y.component_names)
        except Exception:
            names = list(getattr(table.y, "components", []))
        want = f"{type_a}-{type_b}"
        if want not in names and f"{type_b}-{type_a}" in names:
            want = f"{type_b}-{type_a}"
        idx = names.index(want)

        arr = table.xy()
        r = np.asarray(arr[:, 0])
        g = np.asarray(arr[:, 1 + idx])
        return r, g
    finally:
        try: os.remove(xyz)
        except OSError: pass


# ==========================================================
# ================= RDF utilities (no smoothing) ===========
# ==========================================================

def dominant_peak(r: np.ndarray, g: np.ndarray) -> tuple[float, float]:
    """finding the (r_peak, g_peak) at global maximum, which is used to detect the highest peak in a RDF plot."""
    if len(g) == 0:
        return float("nan"), float("nan")
    k = int(np.argmax(g))
    return float(r[k]), float(g[k])


def first_local_max(r: np.ndarray, g: np.ndarray) -> tuple[float, float]:
    """First local maximum: earliest i with g[i-1] < g[i] > g[i+1]; falls back to global max. used for RDF analysis"""
    n = len(g)
    for i in range(1, n - 1):
        if g[i] > g[i - 1] and g[i] > g[i + 1]:
            return float(r[i]), float(g[i])
    return dominant_peak(r, g)


# ==========================================================
# ============== Multi-frame RDF + properties ==============
# ==========================================================

def rdf_using_freud(
    handler: XmoloutHandler,
    *,
    frames: Optional[Iterable[int]] = None,
    types_a: Optional[Iterable[str]] = None,
    types_b: Optional[Iterable[str]] = None,
    r_max: Optional[float] = None,
    bins: int = 200,
    average: bool = True,
    return_stack: bool = False,
) -> Tuple[np.ndarray, Union[np.ndarray, List[np.ndarray]]]:
    """Multi-frame RDF via FREUD.
    - If average=True: returns (r, g_mean).
    - If average=False and return_stack=True: returns (r, [g_i ...]).
    - If average=False and return_stack=False: returns (r, g_last).
    """
    df = handler.dataframe()
    if frames is None:
        frames = range(len(df))
    frames = list(frames)

    r_ref: np.ndarray | None = None
    stack: List[np.ndarray] = []

    for i in frames:
        r, g = rdf_freud_frame(
            handler, frame_index=int(i),
            types_a=types_a, types_b=types_b, r_max=r_max, bins=bins, drop_first_bin=True
        )
        if r_ref is None:
            r_ref = r
        else:
            if len(r) != len(r_ref) or np.max(np.abs(r - r_ref)) > 1e-10:
                raise ValueError("R grids differ between frames; fix bins/r_max.")
        stack.append(g)

    if r_ref is None:
        raise ValueError("No frames selected.")

    if average:
        return r_ref, np.mean(np.vstack(stack), axis=0)
    if return_stack:
        return r_ref, stack
    return r_ref, stack[-1]


def rdf_using_ovito(
    handler: XmoloutHandler,
    *,
    frames: Optional[Iterable[int]] = None,
    r_max: float = 4.0,
    bins: int = 200,
    types_a: Optional[Iterable[str]] = None,  # if both provided => partial
    types_b: Optional[Iterable[str]] = None,
    average: bool = True,
    return_stack: bool = False,
) -> Tuple[np.ndarray, Union[np.ndarray, List[np.ndarray]]]:
    """Multi-frame RDF via OVITO (total or partial if types_a & types_b specified).
    - If average=True: returns (r, g_mean).
    - If average=False and return_stack=True: returns (r, [g_i ...]).
    - If average=False and return_stack=False: returns (r, g_last).
    """
    df = handler.dataframe()
    if frames is None:
        frames = range(len(df))
    frames = list(frames)

    do_partial = (types_a is not None) and (types_b is not None)
    if do_partial:
        ta = next(iter(types_a))
        tb = next(iter(types_b))

    r_ref: np.ndarray | None = None
    stack: List[np.ndarray] = []

    for i in frames:
        if do_partial:
            r, g = rdf_ovito_partial_frame(handler, int(i), r_max=r_max, bins=bins, type_a=str(ta), type_b=str(tb))
        else:
            r, g = rdf_ovito_total_frame(handler, int(i), r_max=r_max, bins=bins)

        if r_ref is None:
            r_ref = r
        else:
            if len(r) != len(r_ref) or np.max(np.abs(r - r_ref)) > 1e-10:
                raise ValueError("R grids differ between frames; fix bins/r_max.")
        stack.append(g)

    if r_ref is None:
        raise ValueError("No frames selected.")

    if average:
        return r_ref, np.mean(np.vstack(stack), axis=0)
    if return_stack:
        return r_ref, stack
    return r_ref, stack[-1]


def rdf_property_over_frames(
    handler: XmoloutHandler,
    *,
    backend: str = "ovito",
    frames: Optional[Iterable[int]] = None,
    property: str = "first_peak",  # 'first_peak' | 'dominant_peak' | 'area' | 'excess_area'
    r_max: Optional[float] = None,  # for OVITO total/partial also accepts float
    bins: int = 200,
    types_a: Optional[Iterable[str]] = None,
    types_b: Optional[Iterable[str]] = None,
) -> pd.DataFrame:
    """Compute a single RDF-derived quantitative property (first_peak, dominant_peak, area, or excess area) for each simulation frame.

    The function calculates a property such as the position or height of the first
    RDF peak, the dominant peak, or the integrated area under the RDF curve. It
    iterates over all selected frames, using either the OVITO or Freud backend
    to compute the RDF, and returns a tidy DataFrame with one row per frame.

    Behavior
    --------
    - For each frame, computes the RDF (`g(r)`) using either:
        * `ovito` — via `rdf_ovito_total_frame` or `rdf_ovito_partial_frame`.
        * `freud` — via `rdf_freud_frame`.
    - Extracts the requested RDF-based property:
        * `"first_peak"` → position and value of first local maximum.
        * `"dominant_peak"` → position and value of highest global peak.
        * `"area"` → total ∫g(r)dr up to `r_max`.
        * `"excess_area"` → ∫(g(r)−1)dr (measures deviation from ideal gas).
    - Returns one row per frame containing frame index, iteration, and the computed values.
    - Supports total or partial RDFs depending on whether `types_a` and `types_b` are given.

    Notes
    -----
    - Valid `property` options: `"first_peak"`, `"dominant_peak"`, `"area"`, `"excess_area"`.
    - `backend` may be `"ovito"` or `"freud"`.
    - For OVITO partial RDFs, only the first element of `types_a` and `types_b` are used.
    - Automatically integrates using `numpy.trapz`.
    - The returned DataFrame is sorted by frame index and includes:
        * **frame_index** — 0-based frame number.
        * **iter** — iteration (if available in handler dataframe).
        * **property columns** — depending on chosen RDF metric.
    """
    df_sim = handler.dataframe()
    if frames is None:
        frames = range(len(df_sim))
    frames = list(frames)

    prop = property.strip().lower()
    allowed = {"first_peak", "dominant_peak", "area", "excess_area"}
    if prop not in allowed:
        raise ValueError(f"property must be one of {allowed}")

    rows: List[Dict[str, float]] = []

    for i in frames:
        if backend.lower() == "freud":
            r, g = rdf_freud_frame(handler, int(i), types_a=types_a, types_b=types_b, r_max=r_max, bins=bins)
        elif backend.lower() == "ovito":
            if (types_a is not None) and (types_b is not None):
                ta = next(iter(types_a)); tb = next(iter(types_b))
                r, g = rdf_ovito_partial_frame(handler, int(i), r_max=float(r_max or 4.0), bins=bins, type_a=str(ta), type_b=str(tb))
            else:
                r, g = rdf_ovito_total_frame(handler, int(i), r_max=float(r_max or 4.0), bins=bins)
        else:
            raise ValueError("backend must be 'freud' or 'ovito'")

        if prop == "first_peak":
            rp, gp = first_local_max(r, g)
            out = {"r_first_peak": rp, "g_first_peak": gp}
        elif prop == "dominant_peak":
            rp, gp = dominant_peak(r, g)
            out = {"r_peak": rp, "g_peak": gp}
        elif prop == "area":
            out = {"area": float(np.trapz(g, r)) if len(r) else np.nan}
        else:  # "excess_area"
            out = {"excess_area": float(np.trapz(g - 1.0, r)) if len(r) else np.nan}

        rows.append({
            "frame_index": int(i),
            "iter": int(df_sim.iloc[i]["iter"]) if "iter" in df_sim.columns else int(i),
            **out,
        })

    return pd.DataFrame(rows).sort_values("frame_index").reset_index(drop=True)
